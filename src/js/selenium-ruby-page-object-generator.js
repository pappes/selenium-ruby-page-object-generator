/**
 * Created by Dave on 4/03/2017. (C)  all rights reserved
 */


//  uncomment the below line of code (and two lines at the bottom)
//  to isolate the scope of the logic in a bookmarklet which will reduce naming conflicts
//  put the resulting function through https://jscompress.com/
//javascript:(function(){


// javascript: (function () {
//     var jsCode = document.createElement('script');
//     jsCode.setAttribute('src', 'http://path/to/external/file.js');
//     document.body.appendChild(jsCode);
// }());
// javascript:!function(){var a=document.createElement("script");a.setAttribute("src","http://pappes.github.io/ezi/selenium-ruby-page-object-generator.js"),document.body.appendChild(a)}();


//TODO: finish 2 tests
//TODO: unit testing using a framework
//TODO: minify with https://jscompress.com/
//TODO: invoke js from an Ezidbeit static site instead of minifying all the logic.


function constructPageObject(webPage) {
    //create the ruby page object and get the browser to write it into the download directory
    const RUBYFILEEXTENSION = '.rb';
    var pageName = getPageName(webPage);
    var fieldCollection = getInteractiveElements(webPage);
    var pageObject = createPageObject(fieldCollection, pageName);
    giveFileToUser(pageName + RUBYFILEEXTENSION, pageObject);
}
function createPageObject(inputFields, pageObjectName) {
    // Get the list of user input fields from the current HTML page and build a Ruby page object file
    var rubyPageObject ='';
    var i = 0;

    rubyPageObject += createPageObjectHeader(pageObjectName);
    for (i = 0; i < inputFields.length; ++i) {
        rubyPageObject += createPageObjectAnnotation(inputFields[i]);
    }
    for (i = 0; i < inputFields.length; ++i) {
        rubyPageObject += createPageObjectMethods(inputFields[i]);
    }
    rubyPageObject += createPageObjectFooter();
    return rubyPageObject;
}
function createPageObjectHeader(title) {
    // import common ruby library, include a header comment and create a ruby class definition for the pageobject
    //sample output:
    //    require_relative "../common_page"
    //    class EBSLoginPage < Page
    const INCLUDELIBRARY      = 'require_relative "../common_page"\n';
    const HEADERPREFIX        = '\nclass ';
    const HEADERSUFFIX        = ' < Page\n\n';

    var header = '';

    header += INCLUDELIBRARY;
    header += getPageObjectHeaderComments();
    header += HEADERPREFIX + title + HEADERSUFFIX;

    return header;
}
function getPageObjectHeaderComments() {
    // spam the user with commentary to discourage manual edits
    const GENERATORCOMMENT    = '#This ruby pageobject file has been generated by a bookmarklet and should not be edited by hand\n';
    const CONFLUENCEREFERENCE = '#For details about the bookmarklet search confluence for "bookmarklet"\n';
    const METADATAPREFIX      = '#It has been generated on ';
    const DONTEDIT1           = '#Please do not edit this file.   If you do edit this file please keep a detailed list\n';
    const DONTEDIT2           = '#of all manual edits so they can be reapplied if the pageobject is regenerated.\n';
    const DONTEDIT3           = '#e.g. Renamed nastyname to CleanName, deleted duplicate copies MaXXy annotation\n';
    const DONTEDIT4           = '#e.g. changed Name annotation for DaveDave to ID annotation daveID\n';
    const DONTEDIT5           = '#e.g. changed changed 4 identical annotation/method instances from DavidHayes to Dave1, Dave2, Dave3, Dave4\n\n';

    var comments = '';
    var today = new Date();

    comments += GENERATORCOMMENT;
    comments += CONFLUENCEREFERENCE;
    comments += METADATAPREFIX + today;
    comments += DONTEDIT1;
    comments += DONTEDIT2;
    comments += DONTEDIT3;
    comments += DONTEDIT4;
    comments += DONTEDIT5;

    return comments;
}
function createPageObjectFooter() {
    //terminate the ruby class definition
    //sample output:
    //    end
    const FOOTERLINE = '\n\nend\n';

    return FOOTERLINE;
}
function createPageObjectAnnotation(inputField) {
    //annotate each input control found on the page
    //sample output:
    //    @@login_button = {:platform => "Web", :id_type => :id, :id_value => "login_button" }
    //    @@user_name = {:platform => "Web", :id_type => :name, :id_value => "user_name" }
    const ANNOTATIONPREFIX   = '    @@';
    const ANNOTATIONIDMID    = ' = {:platform => "Web", :id_type => :id, :id_value => "';
    const ANNOTATIONNAMEMID  = ' = {:platform => "Web", :id_type => :name, :id_value => "';
    const ANNOTATIONXPATHMID = ' = {:platform => "Web", :id_type => :xpath, :id_value => "';
    const ANNOTATIONSUFFIX   = '" }\n';
    const ATTRIBUTENAME      = 'name';
    const ATTRIBUTEID        = 'id';

    var annotations = '';
    var inputName = getInputFieldName(inputField);

    annotations += ANNOTATIONPREFIX;
    annotations += removePunctuation(inputName);
    if (inputField.hasAttribute(ATTRIBUTENAME)) {
        annotations += ANNOTATIONNAMEMID;
    } else if (inputField.hasAttribute(ATTRIBUTEID)) {
        annotations += ANNOTATIONIDMID;
    } else {
        annotations += ANNOTATIONXPATHMID;
    }
    annotations += inputName;
    annotations += ANNOTATIONSUFFIX;

    return annotations;
}
function createPageObjectMethods(inputField) {
    //create an is_present method for each control plus other methods as appropriate (click, toggle, enter, read, etc)
    const INPUTTYPESELECT       = 'select';
    const INPUTTYPECHECKBOX     = 'checkbox';
    const INPUTTYPERADIOBUTTON  = 'radio';
    const INPUTTYPEBUTTON       = 'button';
    const INPUTTYPESUBMITBUTTON = 'submit';
    const INPUTTYPERESETBUTTON  = 'reset';
    const TAGNAMEANCHOR         = 'A';
    const TAGNAMETABLE          = 'TABLE';
    const ISPRESENTMETHOD       = 'is_present';
    const CLICKMETHOD           = 'click';
    const TOGGLEMETHOD          = 'toggle';
    const ENTERMETHOD           = 'enter';
    const READMETHOD            = 'read';
    const SELECTLISTMETHOD      = 'select_list';
    const SELECTOPTIONMETHOD    = 'select_option';
    const READTABLEMETHOD       = 'read_table';
    const ISPRESENTSUFFIX       = '?';
    //sample input types are : button, checkbox, color, date, email, number, radio, submit, time, etc

    var inputName = removePunctuation(getInputFieldName(inputField));
    var method = createPageObjectSimpleMethod(inputName, ISPRESENTMETHOD, ISPRESENTSUFFIX);

    if (inputName !== null) {
        if (inputField.tagName === TAGNAMEANCHOR ||
            inputField.type === INPUTTYPERESETBUTTON ||
            inputField.type === INPUTTYPESUBMITBUTTON ||
            inputField.type === INPUTTYPEBUTTON){
            method += createPageObjectSimpleMethod(inputName, CLICKMETHOD);
        } else if (inputField.type === INPUTTYPERADIOBUTTON){
            method += createPageObjectSimpleMethod(inputName, SELECTOPTIONMETHOD);
        } else if (inputField.type === INPUTTYPESELECT){
            method += createPageObjectSimpleMethod(inputName, SELECTLISTMETHOD);
        } else if (inputField.type === INPUTTYPECHECKBOX){
            method += createPageObjectSimpleMethod(inputName, TOGGLEMETHOD);
        } else if (inputField.type === TAGNAMETABLE){
            method += createPageObjectSimpleMethod(inputName, READTABLEMETHOD);
        } else {
            method += createPageObjectAssignMethod(inputName, ENTERMETHOD);
            method += createPageObjectSimpleMethod(inputName, READMETHOD);
        }
    }
    return method;
}
function createPageObjectSimpleMethod(inputName, methodName, declarationSuffix = '') {
    //define a method that does not have any parameters
    //sample button method:
    //    def self.login_button
    //        click @@login_button
    //    end
    const SIMPLEMETHODPREFIX    = '\n        ';
    const SIMPLEMETHODSUFFIX    = ' @@';

    return wrapMethodInBoilerplate(inputName + declarationSuffix  +
        SIMPLEMETHODPREFIX + methodName + SIMPLEMETHODSUFFIX + inputName);
}
function createPageObjectAssignMethod(fieldName, methodName) {
    //define a method that has a value parameter
    //sample text field method:
    //    def self.user_name=value
    //        enter @@user_name,value
    //    end
    const ASSIGNMETHODMID1   = '=';
    const ASSIGNMETHODMID2   = '\n        ';
    const ASSIGNMETHODMID3   = ' @@';
    const ASSIGNMETHODMID4   = ',';
    const VALUEPARAMETER        = 'value';

    var bareMethod;
    bareMethod = fieldName + ASSIGNMETHODMID1 + VALUEPARAMETER;
    bareMethod += ASSIGNMETHODMID2;
    bareMethod += methodName + ASSIGNMETHODMID3 + fieldName + ASSIGNMETHODMID4 + VALUEPARAMETER;
    return wrapMethodInBoilerplate(bareMethod);
}
function wrapMethodInBoilerplate(bareMethod) {
    //separate the start and end of the method declaration to allow reuse
    //sample button method:
    //    def self.login_button
    //    click @@login_button
    //    end
    const METHODPREFIX          = '\n    def self.';
    const METHODSUFFIX          = '\n    end\n';

    return METHODPREFIX + bareMethod + METHODSUFFIX;
}
function removePunctuation(dirtyString) {
    //the following regex strips all punctuation and then turns spaces to underscores as explained at
    //http://stackoverflow.com/questions/4328500/how-can-i-strip-all-punctuation-from-a-string-in-javascript-using-regex
    return dirtyString.replace(/[^\w\s]/g, "").replace(/\s+/g, "_");
}
function camelize(str) {
    //the following regex converts a string to camelCase as explained at
    //http://stackoverflow.com/questions/2970525/converting-any-string-into-camel-case
    var camel = str.replace(/(?:^\w|[A-Z]|\b\w|\s+)/g, function(match, index) {
        if (+match === 0) return ""; // or if (/\s+/.test(match)) for white spaces
        return index == 0 ? match.toLowerCase() : match.toUpperCase();
    });
    return removePunctuation(camel);
}
function pascalize(text) {
    //convert a string to PascalCase by using camelCase as an intermediate representation
    var camel = camelize(text);
    return camel.charAt(0).toUpperCase() + camel.slice(1);
}
function getInputFieldName(inputField) {
    //find the best human readable identifier available
    //most buttons have a user readable id and no value for name
    //most input fields have a user readable name
    //most anchors have neither name nor id and have spaces in their text
    //ruby identifiers won't like spaces
    var inputName = inputField.name || inputField.id || getXPath(inputField);

    return inputName;
}
function getPageName(webPage) {
    //get the page name from the first header element which contains text content
    //or else use the page title (but throw away everything up to and including the last dash)
    var pageTitle = '';
    var pageHeaders = getHeaderElements(webPage);

    for (i = 0; i < pageHeaders.length; ++i) {
        if (pageHeaders[i].textContent) {
            pageTitle = pageHeaders[i].textContent;
            break;
        }
    }
    if (pageTitle === '')
        pageTitle = webPage.title.split('-').pop();
    return pascalize(pageTitle);
}
function getHeaderElements(webPage) {
    //scan the web page for tags indicating a header is shown to the user
    const HEADERELEMENTS   = 'h1,h2,h3,h4,h5,h6';
    return webPage.querySelectorAll(HEADERELEMENTS);
}
function getInteractiveElements(webPage) {
    //scan the web page for tags indicating an interactive field
    //note: anchors <a> are interactive but not needed in the pageobject
    const INTERACTIVEELEMENTS   = 'table,button,input,select,textarea';
    return webPage.querySelectorAll(INTERACTIVEELEMENTS);
}
function giveFileToUser(fileName, fileContents) {
    //put the contents in a file and get the browser to write it into the downloads area of the client pc
    const ANCHORTAG                  = 'a';
    const ANCHORTARGETATTRIBUTE      = 'href';
    const ANCHORDESTINATIONATTRIBUTE = 'download';
    const PLAINTEXTENCODING          = 'data:text/plain;charset=utf-8,';
    const ELEMENTDISPLAYHIDDEN       = 'none';

    var element = document.createElement(ANCHORTAG);

    element.setAttribute(ANCHORTARGETATTRIBUTE, PLAINTEXTENCODING + encodeURIComponent(fileContents));
    element.setAttribute(ANCHORDESTINATIONATTRIBUTE, fileName);
    element.style.display = ELEMENTDISPLAYHIDDEN;
    document.body.appendChild(element);

    element.click();

    document.body.removeChild(element);
}
function getXPath(element) {
    //construct a deterministic path to the element, even if it is not human friendly e.g.
    // id("walkme-754-tab-content")/DIV[1]/DIV[1]/INPUT[1]
    const XPATHIDPREFIX    = 'id("';
    const XPATHIDSUFFIX    = '")';
    const XPATHSEPARATOR   = '/';
    const XPATHARAYPREFIX  = '[';
    const XPATHARRAYSUFFIX = ']';

    var i = 0;
    var tagIndex = 0;
    var xPath = '';
    var sibling = '';
    var siblings = '';
    if (element.id !== '') {
        xPath = XPATHIDPREFIX + element.id + XPATHIDSUFFIX;
    } else if (element === document.body) {
        xPath = element.tagName;
    } else {
        siblings = element.parentNode.childNodes;
        for (i = 0; i < siblings.length; i++) {
            sibling = siblings[i];
            if (sibling === element) {
                xPath = getXPath(element.parentNode) + XPATHSEPARATOR + element.tagName + XPATHARAYPREFIX + (tagIndex + 1) + XPATHARRAYSUFFIX;
                break;
            } else if (sibling.nodeType === 1 && sibling.tagName === element.tagName) {
                tagIndex++;
            }
        }
    }
    return xPath;
}

//  uncomment the below 2 lines to execute the logic immediately for the current page as a bookmarklet
//constructPageObject(document);
//})();

